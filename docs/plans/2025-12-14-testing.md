# Testing Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add comprehensive unit and integration tests for the MCP Task Manager project.

**Architecture:** Standard Go testing with `go test`. Unit tests for pure logic, integration tests using temp directories for storage. No mocks needed - use real implementations with isolated temp directories.

**Tech Stack:** Go testing, `testing` package, `t.TempDir()` for isolation

---

## Task 1: Unit Tests for Task Model (`internal/task/task.go`)

**Files:**
- Create: `internal/task/task_test.go`

**Step 1: Write the test file**

Create `internal/task/task_test.go`:

```go
package task

import "testing"

func TestPriorityOrder(t *testing.T) {
	tests := []struct {
		priority Priority
		expected int
	}{
		{PriorityCritical, 0},
		{PriorityHigh, 1},
		{PriorityMedium, 2},
		{PriorityLow, 3},
		{Priority("unknown"), 99},
	}

	for _, tt := range tests {
		t.Run(string(tt.priority), func(t *testing.T) {
			if got := tt.priority.Order(); got != tt.expected {
				t.Errorf("Priority(%q).Order() = %d, want %d", tt.priority, got, tt.expected)
			}
		})
	}
}

func TestIsValidStatus(t *testing.T) {
	tests := []struct {
		status string
		valid  bool
	}{
		{"todo", true},
		{"in_progress", true},
		{"done", true},
		{"invalid", false},
		{"", false},
		{"TODO", false}, // case sensitive
	}

	for _, tt := range tests {
		t.Run(tt.status, func(t *testing.T) {
			if got := IsValidStatus(tt.status); got != tt.valid {
				t.Errorf("IsValidStatus(%q) = %v, want %v", tt.status, got, tt.valid)
			}
		})
	}
}

func TestIsValidPriority(t *testing.T) {
	tests := []struct {
		priority string
		valid    bool
	}{
		{"critical", true},
		{"high", true},
		{"medium", true},
		{"low", true},
		{"invalid", false},
		{"", false},
		{"HIGH", false}, // case sensitive
	}

	for _, tt := range tests {
		t.Run(tt.priority, func(t *testing.T) {
			if got := IsValidPriority(tt.priority); got != tt.valid {
				t.Errorf("IsValidPriority(%q) = %v, want %v", tt.priority, got, tt.valid)
			}
		})
	}
}
```

**Step 2: Run tests to verify they pass**

Run: `go test ./internal/task/... -v -run "TestPriority|TestIsValid"`
Expected: All tests PASS

**Step 3: Commit**

```bash
git add internal/task/task_test.go
git commit -m "test: add unit tests for task model validation"
```

---

## Task 2: Unit Tests for Config (`internal/config/config.go`)

**Files:**
- Create: `internal/config/config_test.go`

**Step 1: Write the test file**

Create `internal/config/config_test.go`:

```go
package config

import (
	"os"
	"path/filepath"
	"testing"
)

func TestDefaultConfig(t *testing.T) {
	cfg := DefaultConfig()

	if cfg.DataDir != "./tasks" {
		t.Errorf("DefaultConfig().DataDir = %q, want %q", cfg.DataDir, "./tasks")
	}

	if len(cfg.TaskTypes) != 2 {
		t.Errorf("DefaultConfig().TaskTypes length = %d, want 2", len(cfg.TaskTypes))
	}

	expectedTypes := map[string]bool{"feature": true, "bug": true}
	for _, tt := range cfg.TaskTypes {
		if !expectedTypes[tt] {
			t.Errorf("unexpected task type: %q", tt)
		}
	}
}

func TestIsValidTaskType(t *testing.T) {
	cfg := &Config{
		TaskTypes: []string{"feature", "bug", "chore"},
	}

	tests := []struct {
		taskType string
		valid    bool
	}{
		{"feature", true},
		{"bug", true},
		{"chore", true},
		{"invalid", false},
		{"", false},
	}

	for _, tt := range tests {
		t.Run(tt.taskType, func(t *testing.T) {
			if got := cfg.IsValidTaskType(tt.taskType); got != tt.valid {
				t.Errorf("IsValidTaskType(%q) = %v, want %v", tt.taskType, got, tt.valid)
			}
		})
	}
}

func TestTasksDir_Absolute(t *testing.T) {
	cfg := &Config{DataDir: "/absolute/path"}
	if got := cfg.TasksDir(); got != "/absolute/path" {
		t.Errorf("TasksDir() = %q, want %q", got, "/absolute/path")
	}
}

func TestTasksDir_Relative(t *testing.T) {
	cfg := &Config{DataDir: "./tasks"}
	cwd, _ := os.Getwd()
	expected := filepath.Join(cwd, "./tasks")

	if got := cfg.TasksDir(); got != expected {
		t.Errorf("TasksDir() = %q, want %q", got, expected)
	}
}

func TestLoad_WithEnvOverride(t *testing.T) {
	// Save and restore env
	oldVal := os.Getenv("MCP_TASKS_DIR")
	defer os.Setenv("MCP_TASKS_DIR", oldVal)

	os.Setenv("MCP_TASKS_DIR", "/custom/path")

	cfg, err := Load()
	if err != nil {
		t.Fatalf("Load() error = %v", err)
	}

	if cfg.DataDir != "/custom/path" {
		t.Errorf("Load() DataDir = %q, want %q", cfg.DataDir, "/custom/path")
	}
}
```

**Step 2: Run tests to verify they pass**

Run: `go test ./internal/config/... -v`
Expected: All tests PASS

**Step 3: Commit**

```bash
git add internal/config/config_test.go
git commit -m "test: add unit tests for config loading"
```

---

## Task 3: Integration Tests for Storage (`internal/storage/`)

**Files:**
- Create: `internal/storage/storage_test.go`

**Step 1: Write the test file**

Create `internal/storage/storage_test.go`:

```go
package storage

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/gpayer/mcp-task-manager/internal/task"
)

func TestMarkdownStorage_SaveAndLoad(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)

	now := time.Now().UTC().Truncate(time.Second)
	original := &task.Task{
		ID:          1,
		Title:       "Test Task",
		Description: "This is a test description.\n\nWith multiple paragraphs.",
		Status:      task.StatusTodo,
		Priority:    task.PriorityHigh,
		Type:        "feature",
		CreatedAt:   now,
		UpdatedAt:   now,
	}

	// Save
	if err := storage.Save(original); err != nil {
		t.Fatalf("Save() error = %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(filepath.Join(dir, "001.md")); os.IsNotExist(err) {
		t.Fatal("expected 001.md to exist")
	}

	// Load
	loaded, err := storage.Load(1)
	if err != nil {
		t.Fatalf("Load() error = %v", err)
	}

	// Compare fields
	if loaded.ID != original.ID {
		t.Errorf("ID = %d, want %d", loaded.ID, original.ID)
	}
	if loaded.Title != original.Title {
		t.Errorf("Title = %q, want %q", loaded.Title, original.Title)
	}
	if loaded.Description != original.Description {
		t.Errorf("Description = %q, want %q", loaded.Description, original.Description)
	}
	if loaded.Status != original.Status {
		t.Errorf("Status = %q, want %q", loaded.Status, original.Status)
	}
	if loaded.Priority != original.Priority {
		t.Errorf("Priority = %q, want %q", loaded.Priority, original.Priority)
	}
	if loaded.Type != original.Type {
		t.Errorf("Type = %q, want %q", loaded.Type, original.Type)
	}
}

func TestMarkdownStorage_Delete(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)

	task := &task.Task{
		ID:        1,
		Title:     "To Delete",
		Status:    task.StatusTodo,
		Priority:  task.PriorityMedium,
		Type:      "bug",
		CreatedAt: time.Now().UTC(),
		UpdatedAt: time.Now().UTC(),
	}

	if err := storage.Save(task); err != nil {
		t.Fatalf("Save() error = %v", err)
	}

	if err := storage.Delete(1); err != nil {
		t.Fatalf("Delete() error = %v", err)
	}

	if _, err := storage.Load(1); !os.IsNotExist(err) {
		t.Errorf("expected file to be deleted, got error: %v", err)
	}
}

func TestMarkdownStorage_LoadAll(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)

	now := time.Now().UTC()
	tasks := []*task.Task{
		{ID: 1, Title: "Task 1", Status: task.StatusTodo, Priority: task.PriorityHigh, Type: "feature", CreatedAt: now, UpdatedAt: now},
		{ID: 2, Title: "Task 2", Status: task.StatusDone, Priority: task.PriorityLow, Type: "bug", CreatedAt: now, UpdatedAt: now},
		{ID: 3, Title: "Task 3", Status: task.StatusInProgress, Priority: task.PriorityMedium, Type: "feature", CreatedAt: now, UpdatedAt: now},
	}

	for _, tk := range tasks {
		if err := storage.Save(tk); err != nil {
			t.Fatalf("Save() error = %v", err)
		}
	}

	loaded, err := storage.LoadAll()
	if err != nil {
		t.Fatalf("LoadAll() error = %v", err)
	}

	if len(loaded) != 3 {
		t.Errorf("LoadAll() returned %d tasks, want 3", len(loaded))
	}
}

func TestMarkdownStorage_NextID(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)

	// Empty directory
	id, err := storage.NextID()
	if err != nil {
		t.Fatalf("NextID() error = %v", err)
	}
	if id != 1 {
		t.Errorf("NextID() on empty dir = %d, want 1", id)
	}

	// Add some tasks
	now := time.Now().UTC()
	for _, i := range []int{1, 5, 3} {
		tk := &task.Task{ID: i, Title: "Task", Status: task.StatusTodo, Priority: task.PriorityMedium, Type: "feature", CreatedAt: now, UpdatedAt: now}
		if err := storage.Save(tk); err != nil {
			t.Fatalf("Save() error = %v", err)
		}
	}

	id, err = storage.NextID()
	if err != nil {
		t.Fatalf("NextID() error = %v", err)
	}
	if id != 6 {
		t.Errorf("NextID() = %d, want 6", id)
	}
}
```

**Step 2: Run tests to verify they pass**

Run: `go test ./internal/storage/... -v`
Expected: All tests PASS

**Step 3: Commit**

```bash
git add internal/storage/storage_test.go
git commit -m "test: add integration tests for markdown storage"
```

---

## Task 4: Integration Tests for Index (`internal/storage/`)

**Files:**
- Modify: `internal/storage/storage_test.go`

**Step 1: Add index tests to the existing test file**

Append to `internal/storage/storage_test.go`:

```go

func TestIndex_SetGetDelete(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)
	idx := NewIndex(dir, storage)

	now := time.Now().UTC()
	tk := &task.Task{
		ID:        1,
		Title:     "Test",
		Status:    task.StatusTodo,
		Priority:  task.PriorityHigh,
		Type:      "feature",
		CreatedAt: now,
		UpdatedAt: now,
	}

	// Set
	idx.Set(tk)

	// Get
	got, ok := idx.Get(1)
	if !ok {
		t.Fatal("Get() returned false for existing task")
	}
	if got.Title != tk.Title {
		t.Errorf("Get() title = %q, want %q", got.Title, tk.Title)
	}

	// Delete
	idx.Delete(1)
	_, ok = idx.Get(1)
	if ok {
		t.Error("Get() returned true for deleted task")
	}
}

func TestIndex_Filter(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)
	idx := NewIndex(dir, storage)

	now := time.Now().UTC()
	tasks := []*task.Task{
		{ID: 1, Title: "Task 1", Status: task.StatusTodo, Priority: task.PriorityHigh, Type: "feature", CreatedAt: now, UpdatedAt: now},
		{ID: 2, Title: "Task 2", Status: task.StatusDone, Priority: task.PriorityLow, Type: "bug", CreatedAt: now, UpdatedAt: now},
		{ID: 3, Title: "Task 3", Status: task.StatusTodo, Priority: task.PriorityMedium, Type: "feature", CreatedAt: now, UpdatedAt: now},
	}
	for _, tk := range tasks {
		idx.Set(tk)
	}

	// Filter by status
	todoStatus := task.StatusTodo
	filtered := idx.Filter(&todoStatus, nil, nil)
	if len(filtered) != 2 {
		t.Errorf("Filter by todo status returned %d tasks, want 2", len(filtered))
	}

	// Filter by priority
	highPriority := task.PriorityHigh
	filtered = idx.Filter(nil, &highPriority, nil)
	if len(filtered) != 1 {
		t.Errorf("Filter by high priority returned %d tasks, want 1", len(filtered))
	}

	// Filter by type
	featureType := "feature"
	filtered = idx.Filter(nil, nil, &featureType)
	if len(filtered) != 2 {
		t.Errorf("Filter by feature type returned %d tasks, want 2", len(filtered))
	}

	// Combined filter
	filtered = idx.Filter(&todoStatus, nil, &featureType)
	if len(filtered) != 2 {
		t.Errorf("Combined filter returned %d tasks, want 2", len(filtered))
	}
}

func TestIndex_NextTodo(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)
	idx := NewIndex(dir, storage)

	// Empty index
	if got := idx.NextTodo(); got != nil {
		t.Errorf("NextTodo() on empty index = %v, want nil", got)
	}

	now := time.Now().UTC()
	tasks := []*task.Task{
		{ID: 1, Title: "Low", Status: task.StatusTodo, Priority: task.PriorityLow, Type: "feature", CreatedAt: now, UpdatedAt: now},
		{ID: 2, Title: "Critical", Status: task.StatusTodo, Priority: task.PriorityCritical, Type: "bug", CreatedAt: now.Add(time.Hour), UpdatedAt: now},
		{ID: 3, Title: "Critical Older", Status: task.StatusTodo, Priority: task.PriorityCritical, Type: "feature", CreatedAt: now, UpdatedAt: now},
		{ID: 4, Title: "Done", Status: task.StatusDone, Priority: task.PriorityCritical, Type: "bug", CreatedAt: now, UpdatedAt: now},
	}
	for _, tk := range tasks {
		idx.Set(tk)
	}

	// Should return Critical Older (highest priority, oldest)
	next := idx.NextTodo()
	if next == nil {
		t.Fatal("NextTodo() returned nil")
	}
	if next.ID != 3 {
		t.Errorf("NextTodo() ID = %d, want 3 (Critical Older)", next.ID)
	}
}

func TestIndex_NextID(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)
	idx := NewIndex(dir, storage)

	// Empty
	if got := idx.NextID(); got != 1 {
		t.Errorf("NextID() on empty = %d, want 1", got)
	}

	// Add tasks
	now := time.Now().UTC()
	idx.Set(&task.Task{ID: 5, Title: "Task", Status: task.StatusTodo, Priority: task.PriorityMedium, Type: "feature", CreatedAt: now, UpdatedAt: now})
	idx.Set(&task.Task{ID: 3, Title: "Task", Status: task.StatusTodo, Priority: task.PriorityMedium, Type: "feature", CreatedAt: now, UpdatedAt: now})

	if got := idx.NextID(); got != 6 {
		t.Errorf("NextID() = %d, want 6", got)
	}
}

func TestIndex_SaveAndLoad(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)
	idx := NewIndex(dir, storage)

	now := time.Now().UTC()
	tk := &task.Task{
		ID:        1,
		Title:     "Persisted",
		Status:    task.StatusTodo,
		Priority:  task.PriorityHigh,
		Type:      "feature",
		CreatedAt: now,
		UpdatedAt: now,
	}
	idx.Set(tk)

	if err := idx.Save(); err != nil {
		t.Fatalf("Save() error = %v", err)
	}

	// Create new index and load
	idx2 := NewIndex(dir, storage)
	if err := idx2.Load(); err != nil {
		t.Fatalf("Load() error = %v", err)
	}

	got, ok := idx2.Get(1)
	if !ok {
		t.Fatal("Get() after Load() returned false")
	}
	if got.Title != tk.Title {
		t.Errorf("Title after Load() = %q, want %q", got.Title, tk.Title)
	}
}

func TestIndex_RebuildFromFiles(t *testing.T) {
	dir := t.TempDir()
	storage := NewMarkdownStorage(dir)

	// Save tasks directly to storage
	now := time.Now().UTC()
	tasks := []*task.Task{
		{ID: 1, Title: "Task 1", Status: task.StatusTodo, Priority: task.PriorityHigh, Type: "feature", CreatedAt: now, UpdatedAt: now},
		{ID: 2, Title: "Task 2", Status: task.StatusDone, Priority: task.PriorityLow, Type: "bug", CreatedAt: now, UpdatedAt: now},
	}
	for _, tk := range tasks {
		if err := storage.Save(tk); err != nil {
			t.Fatalf("Save() error = %v", err)
		}
	}

	// Create index without existing index file (triggers rebuild)
	idx := NewIndex(dir, storage)
	if err := idx.Load(); err != nil {
		t.Fatalf("Load() error = %v", err)
	}

	// Verify tasks were loaded
	all := idx.All()
	if len(all) != 2 {
		t.Errorf("All() after rebuild returned %d tasks, want 2", len(all))
	}
}
```

**Step 2: Run tests to verify they pass**

Run: `go test ./internal/storage/... -v`
Expected: All tests PASS

**Step 3: Commit**

```bash
git add internal/storage/storage_test.go
git commit -m "test: add integration tests for index operations"
```

---

## Task 5: Integration Tests for Task Service (`internal/task/`)

**Files:**
- Create: `internal/task/service_test.go`

**Step 1: Write the test file**

Create `internal/task/service_test.go`:

```go
package task

import (
	"testing"
	"time"
)

// mockStorage implements Storage interface for testing
type mockStorage struct {
	tasks map[int]*Task
}

func newMockStorage() *mockStorage {
	return &mockStorage{tasks: make(map[int]*Task)}
}

func (m *mockStorage) Save(t *Task) error {
	m.tasks[t.ID] = t
	return nil
}

func (m *mockStorage) Load(id int) (*Task, error) {
	return m.tasks[id], nil
}

func (m *mockStorage) Delete(id int) error {
	delete(m.tasks, id)
	return nil
}

func (m *mockStorage) EnsureDir() error {
	return nil
}

// mockIndex implements Index interface for testing
type mockIndex struct {
	tasks  map[int]*Task
	nextID int
}

func newMockIndex() *mockIndex {
	return &mockIndex{tasks: make(map[int]*Task), nextID: 1}
}

func (m *mockIndex) Load() error  { return nil }
func (m *mockIndex) Save() error  { return nil }

func (m *mockIndex) Get(id int) (*Task, bool) {
	t, ok := m.tasks[id]
	return t, ok
}

func (m *mockIndex) Set(t *Task) {
	m.tasks[t.ID] = t
	if t.ID >= m.nextID {
		m.nextID = t.ID + 1
	}
}

func (m *mockIndex) Delete(id int) {
	delete(m.tasks, id)
}

func (m *mockIndex) All() []*Task {
	result := make([]*Task, 0, len(m.tasks))
	for _, t := range m.tasks {
		result = append(result, t)
	}
	return result
}

func (m *mockIndex) Filter(status *Status, priority *Priority, taskType *string) []*Task {
	var result []*Task
	for _, t := range m.tasks {
		if status != nil && t.Status != *status {
			continue
		}
		if priority != nil && t.Priority != *priority {
			continue
		}
		if taskType != nil && t.Type != *taskType {
			continue
		}
		result = append(result, t)
	}
	return result
}

func (m *mockIndex) NextTodo() *Task {
	var best *Task
	for _, t := range m.tasks {
		if t.Status != StatusTodo {
			continue
		}
		if best == nil || t.Priority.Order() < best.Priority.Order() ||
			(t.Priority.Order() == best.Priority.Order() && t.CreatedAt.Before(best.CreatedAt)) {
			best = t
		}
	}
	return best
}

func (m *mockIndex) NextID() int {
	return m.nextID
}

func TestService_Create(t *testing.T) {
	svc := NewService(newMockStorage(), newMockIndex(), []string{"feature", "bug"})
	if err := svc.Initialize(); err != nil {
		t.Fatalf("Initialize() error = %v", err)
	}

	task, err := svc.Create("Test Task", "Description", PriorityHigh, "feature")
	if err != nil {
		t.Fatalf("Create() error = %v", err)
	}

	if task.ID != 1 {
		t.Errorf("ID = %d, want 1", task.ID)
	}
	if task.Title != "Test Task" {
		t.Errorf("Title = %q, want %q", task.Title, "Test Task")
	}
	if task.Status != StatusTodo {
		t.Errorf("Status = %q, want %q", task.Status, StatusTodo)
	}
}

func TestService_Create_Validation(t *testing.T) {
	svc := NewService(newMockStorage(), newMockIndex(), []string{"feature", "bug"})
	svc.Initialize()

	tests := []struct {
		name     string
		title    string
		priority Priority
		taskType string
		wantErr  bool
	}{
		{"valid", "Title", PriorityHigh, "feature", false},
		{"empty title", "", PriorityHigh, "feature", true},
		{"invalid priority", "Title", Priority("invalid"), "feature", true},
		{"invalid type", "Title", PriorityHigh, "invalid", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := svc.Create(tt.title, "desc", tt.priority, tt.taskType)
			if (err != nil) != tt.wantErr {
				t.Errorf("Create() error = %v, wantErr = %v", err, tt.wantErr)
			}
		})
	}
}

func TestService_Update(t *testing.T) {
	svc := NewService(newMockStorage(), newMockIndex(), []string{"feature", "bug"})
	svc.Initialize()

	task, _ := svc.Create("Original", "Desc", PriorityMedium, "feature")

	newTitle := "Updated"
	newStatus := StatusInProgress
	updated, err := svc.Update(task.ID, &newTitle, nil, &newStatus, nil, nil)
	if err != nil {
		t.Fatalf("Update() error = %v", err)
	}

	if updated.Title != "Updated" {
		t.Errorf("Title = %q, want %q", updated.Title, "Updated")
	}
	if updated.Status != StatusInProgress {
		t.Errorf("Status = %q, want %q", updated.Status, StatusInProgress)
	}
}

func TestService_Delete(t *testing.T) {
	svc := NewService(newMockStorage(), newMockIndex(), []string{"feature", "bug"})
	svc.Initialize()

	task, _ := svc.Create("To Delete", "Desc", PriorityMedium, "feature")

	if err := svc.Delete(task.ID); err != nil {
		t.Fatalf("Delete() error = %v", err)
	}

	if _, err := svc.Get(task.ID); err == nil {
		t.Error("Get() after Delete() should return error")
	}
}

func TestService_TaskWorkflow(t *testing.T) {
	svc := NewService(newMockStorage(), newMockIndex(), []string{"feature", "bug"})
	svc.Initialize()

	// Create
	task, _ := svc.Create("Workflow Test", "Desc", PriorityHigh, "feature")
	if task.Status != StatusTodo {
		t.Fatalf("initial status = %q, want todo", task.Status)
	}

	// Start
	task, err := svc.StartTask(task.ID)
	if err != nil {
		t.Fatalf("StartTask() error = %v", err)
	}
	if task.Status != StatusInProgress {
		t.Errorf("status after start = %q, want in_progress", task.Status)
	}

	// Complete
	task, err = svc.CompleteTask(task.ID)
	if err != nil {
		t.Fatalf("CompleteTask() error = %v", err)
	}
	if task.Status != StatusDone {
		t.Errorf("status after complete = %q, want done", task.Status)
	}
}

func TestService_StartTask_InvalidState(t *testing.T) {
	svc := NewService(newMockStorage(), newMockIndex(), []string{"feature", "bug"})
	svc.Initialize()

	task, _ := svc.Create("Test", "Desc", PriorityHigh, "feature")

	// Start the task
	svc.StartTask(task.ID)

	// Try to start again - should fail
	_, err := svc.StartTask(task.ID)
	if err == nil {
		t.Error("StartTask() on in_progress task should fail")
	}
}

func TestService_CompleteTask_InvalidState(t *testing.T) {
	svc := NewService(newMockStorage(), newMockIndex(), []string{"feature", "bug"})
	svc.Initialize()

	task, _ := svc.Create("Test", "Desc", PriorityHigh, "feature")

	// Try to complete without starting - should fail
	_, err := svc.CompleteTask(task.ID)
	if err == nil {
		t.Error("CompleteTask() on todo task should fail")
	}
}

func TestService_GetNextTask(t *testing.T) {
	svc := NewService(newMockStorage(), newMockIndex(), []string{"feature", "bug"})
	svc.Initialize()

	// Empty
	if got := svc.GetNextTask(); got != nil {
		t.Errorf("GetNextTask() on empty = %v, want nil", got)
	}

	// Add tasks with different priorities
	svc.Create("Low", "Desc", PriorityLow, "feature")
	time.Sleep(time.Millisecond) // Ensure different timestamps
	svc.Create("Critical", "Desc", PriorityCritical, "bug")

	next := svc.GetNextTask()
	if next == nil {
		t.Fatal("GetNextTask() returned nil")
	}
	if next.Priority != PriorityCritical {
		t.Errorf("GetNextTask() priority = %q, want critical", next.Priority)
	}
}

func TestService_List(t *testing.T) {
	svc := NewService(newMockStorage(), newMockIndex(), []string{"feature", "bug"})
	svc.Initialize()

	svc.Create("Task 1", "Desc", PriorityHigh, "feature")
	svc.Create("Task 2", "Desc", PriorityLow, "bug")
	svc.Create("Task 3", "Desc", PriorityMedium, "feature")

	// All
	all := svc.List(nil, nil, nil)
	if len(all) != 3 {
		t.Errorf("List() all = %d, want 3", len(all))
	}

	// By type
	featureType := "feature"
	features := svc.List(nil, nil, &featureType)
	if len(features) != 2 {
		t.Errorf("List() by feature = %d, want 2", len(features))
	}
}
```

**Step 2: Run tests to verify they pass**

Run: `go test ./internal/task/... -v`
Expected: All tests PASS

**Step 3: Commit**

```bash
git add internal/task/service_test.go
git commit -m "test: add integration tests for task service"
```

---

## Task 6: Final Test Run and Verification

**Step 1: Run all tests with coverage**

Run: `go test ./... -v -cover`
Expected: All tests PASS with coverage report

**Step 2: Verify build still works**

Run: `go build ./cmd/mcp-task-manager`
Expected: Successful build

**Step 3: Commit final state if any cleanup needed**

If any fixes were required during the full test run, commit them:

```bash
git add -A
git commit -m "test: complete test suite with coverage"
```
