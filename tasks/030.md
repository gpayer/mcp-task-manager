---
id: 30
parent_id: 27
title: 'Task 3: Update Save/Load with new IndexFile format and git tracking'
status: in_progress
priority: medium
type: feature
created_at: "2026-01-25T14:07:17Z"
updated_at: "2026-01-25T14:37:13Z"
---

**Files:**
- Modify: `internal/storage/index.go`
- Test: `internal/storage/storage_test.go`

**Steps:**
1. Write failing test for new index format with git commit:

```go
func TestIndex_SaveLoad_WithGitCommit(t *testing.T) {
    dir := t.TempDir()
    storage := NewMarkdownStorage(dir)
    idx := NewIndex(dir, storage)

    now := time.Now().UTC()
    tk := &task.Task{
        ID:        1,
        Title:     "Test",
        Status:    task.StatusTodo,
        Priority:  task.PriorityHigh,
        Type:      "feature",
        CreatedAt: now,
        UpdatedAt: now,
    }
    idx.Set(tk)

    if err := idx.Save(); err != nil {
        t.Fatalf("Save() error = %v", err)
    }

    // Read raw index file and verify structure
    data, err := os.ReadFile(filepath.Join(dir, ".index.json"))
    if err != nil {
        t.Fatalf("ReadFile error = %v", err)
    }

    var indexFile IndexFile
    if err := json.Unmarshal(data, &indexFile); err != nil {
        t.Fatalf("Unmarshal error = %v", err)
    }

    // Git commit might be empty if test dir is not in git
    // but tasks should be present
    if len(indexFile.Tasks) != 1 {
        t.Errorf("Tasks count = %d, want 1", len(indexFile.Tasks))
    }
    if indexFile.Tasks[0].Title != "Test" {
        t.Errorf("Task title = %q, want 'Test'", indexFile.Tasks[0].Title)
    }
}
```

2. Run test to verify failure: `go test ./internal/storage/... -run TestIndex_SaveLoad_WithGitCommit -v`

3. Update `Save()` to write new format with git commit:

```go
func (idx *Index) Save() error {
    if err := os.MkdirAll(idx.dir, 0755); err != nil {
        return err
    }

    // Get current git commit
    gitCommit, _ := getGitCommit(idx.dir)

    // Build entries slice sorted by ID
    entries := make([]*IndexEntry, 0, len(idx.entries))
    for _, e := range idx.entries {
        entries = append(entries, e)
    }
    sort.Slice(entries, func(i, j int) bool {
        return entries[i].ID < entries[j].ID
    })

    indexFile := IndexFile{
        GitCommit: gitCommit,
        Tasks:     entries,
    }

    data, err := json.MarshalIndent(indexFile, "", "  ")
    if err != nil {
        return err
    }

    tmpPath := idx.indexPath() + ".tmp"
    if err := os.WriteFile(tmpPath, data, 0644); err != nil {
        return err
    }
    return os.Rename(tmpPath, idx.indexPath())
}
```

4. Run test to verify pass: `go test ./internal/storage/... -run TestIndex_SaveLoad_WithGitCommit -v`

5. Write failing test for git commit change triggering rebuild:

```go
func TestIndex_Load_RebuildOnGitChange(t *testing.T) {
    dir := t.TempDir()
    storage := NewMarkdownStorage(dir)

    // Save a task directly to storage
    now := time.Now().UTC()
    tk := &task.Task{ID: 1, Title: "From File", Status: task.StatusTodo, Priority: task.PriorityHigh, Type: "feature", CreatedAt: now, UpdatedAt: now}
    storage.Save(tk)

    // Create index file with different git commit
    indexFile := IndexFile{
        GitCommit: "fake_old_commit_that_does_not_exist",
        Tasks: []*IndexEntry{
            {ID: 99, Title: "Old Cached", Status: task.StatusDone, Priority: task.PriorityLow, Type: "bug", CreatedAt: now, UpdatedAt: now},
        },
    }
    data, _ := json.MarshalIndent(indexFile, "", "  ")
    os.WriteFile(filepath.Join(dir, ".index.json"), data, 0644)

    // Load index - should rebuild because git commit doesn't match
    idx := NewIndex(dir, storage)
    if err := idx.Load(); err != nil {
        t.Fatalf("Load() error = %v", err)
    }

    // Should have task from file, not from stale index
    _, ok := idx.GetEntry(1)
    if !ok {
        t.Error("Task 1 (from file) should exist after rebuild")
    }
    _, ok = idx.GetEntry(99)
    if ok {
        t.Error("Task 99 (stale) should not exist after rebuild")
    }
}
```

6. Run test to verify failure: `go test ./internal/storage/... -run TestIndex_Load_RebuildOnGitChange -v`

7. Update `Load()` to check git commit and rebuild if stale:

```go
func (idx *Index) Load() error {
    data, err := os.ReadFile(idx.indexPath())
    if err != nil {
        return idx.Rebuild()  // Missing index
    }

    var indexFile IndexFile
    if err := json.Unmarshal(data, &indexFile); err != nil {
        return idx.Rebuild()  // Corrupt or old format index
    }

    // Check git commit - rebuild if stale
    currentCommit, _ := getGitCommit(idx.dir)
    if currentCommit != "" && indexFile.GitCommit != currentCommit {
        return idx.Rebuild()  // Stale index (git changed)
    }

    // Empty commit in file with non-empty current = stale (migration case)
    if currentCommit != "" && indexFile.GitCommit == "" {
        return idx.Rebuild()
    }

    // Load entries into memory
    idx.entries = make(map[int]*IndexEntry)
    for _, e := range indexFile.Tasks {
        idx.entries[e.ID] = e
    }
    return nil
}
```

8. Run test to verify pass: `go test ./internal/storage/... -run TestIndex_Load_RebuildOnGitChange -v`

9. Write test for backward compatibility (old format triggers rebuild):

```go
func TestIndex_Load_MigratesOldFormat(t *testing.T) {
    dir := t.TempDir()
    storage := NewMarkdownStorage(dir)

    // Save task to storage
    now := time.Now().UTC()
    tk := &task.Task{ID: 1, Title: "Task", Status: task.StatusTodo, Priority: task.PriorityHigh, Type: "feature", CreatedAt: now, UpdatedAt: now}
    storage.Save(tk)

    // Write old format index (raw array)
    oldData := `[{"id":1,"title":"Stale","status":"done","priority":"low","type":"bug"}]`
    os.WriteFile(filepath.Join(dir, ".index.json"), []byte(oldData), 0644)

    // Load should fail to parse as IndexFile and rebuild
    idx := NewIndex(dir, storage)
    if err := idx.Load(); err != nil {
        t.Fatalf("Load() error = %v", err)
    }

    // Should have fresh data from file
    e, ok := idx.GetEntry(1)
    if !ok {
        t.Fatal("Task 1 should exist")
    }
    if e.Title != "Task" {
        t.Errorf("Title = %q, want 'Task' (from file)", e.Title)
    }
    if e.Status != task.StatusTodo {
        t.Errorf("Status = %q, want 'todo' (from file)", e.Status)
    }
}
```

10. Run test to verify pass: `go test ./internal/storage/... -run TestIndex_Load_MigratesOldFormat -v`

11. Run all storage tests: `go test ./internal/storage/... -v`

12. Commit with message: `feat(storage): add git commit tracking to index file`

**Verification:**
`go test ./internal/storage/... -v`